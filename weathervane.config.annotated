{
  "configurationSize" : "small",
  "description" : "A single run findMax with a small configuration",
 
  "maxDuration" : 7200,
  "maxUsers" : 1000,

  "dockerNamespace" : "aname",

  "loglevel" : 1, 
  "truncateLogs" : true,
  "maxLogLines" : 4000,

  "resultsFileDir" : "",
  "resultsFileName" : "weathervaneResults.csv",
  "showPeriodicOutput" : false,

  "redeploy" : false,
  "reloadDb" : false,
  "stopServices" : true,
  "stopOnFailure" : true,

  "responseTimePassingPercentile" : 0.99,

  # Need to consider these further.  Currently allow calling a script 
  # on the runHarness VM, but this won't be possible with the 
  # harness in a container.  
  "startStatsScript" : "/path/to/script/scriptname.sh",
  "stopStatsScript" : "/path/to/script/scriptname.sh",

  # There should be a subclass of runStrategy for each type
  "runStrategy" : {
    "type": "findMaxSingleAI",

    # Different run strategies will have different parameters.
    # Parameters for fixed runStrategy
    "users" : 1000,
    "runLength" : "short", # short, medium, or long
    "rampUp" : 600,
    "steadyState" : 900,
    "rampDown" : 120,
  
    # findMax run strategy is the multi-run findMax
    # findMax run strategy has the same parameters as fixed, plus the following:
    "initialRateStep" : 500,
    "minRateStep" : 250,
    "repeatsAtMax" : 0,

    # targetUtilization run strategy has the same parameters as fixed, plus
    # the following:
    "targetUtilization" : 70,
    "targetUtilizationMarginPct" : 0.02,
    "targetUtilizationServiceType" : "auctionAppServer",

    # custom run strategy allows the user to specify a loadPath. 
    # custom run strategy has the same parameters as fixed, plus the following:
    "loadPath" : [
      {"duration" : 300, "users" : 2000, },  # fixed interval
      {"duration" : 420, "startUsers" : 2000, "endUsers" : 40000, "timeStep" : 10}, # ramp interval
      {"duration" : 120, "endUsers" : 30000, },
      {"duration" : 180, "users" : 30000, },
    ],
    "repeatLoadPath" : true,
  
  },

  "runProcedure" : "full", # Possible values: full, loadOnly, prepareOnly, runOnly, stop

  "interactive" : false,

  # computeResources is a list of ComputeResources
  # ComputeResources are either docker hosts or kubernetes clusters
  # Getting rid of plain VMs.  Can run in VMs by running in Docker and having one service per Docker host/VM.
  # Unlike in the current run harness, the computeResources need to be explicitly defined.  
  # Note: At some point we would like to be able to reference computeResources from set of previously 
  # defined values (e.g. from a database).
  "computeResources" : [
    {
      "name" : "aHostName1",
      "type" : "docker",
      "vicHost" : false,
      "dockerHostPort" : 2376,
    },
    {
      "name" : "aHostName2",
      "type" : "docker",
      "vicHost" : false,
      "dockerHostPort" : 2376,
    },
    {
      "name" : "aClusterName",
      "type" : "kubernetes",

      "kubernetesConfigFile" : "filePointer",
    },
    {
      "name" : "driverClusterName",
      "type" : "kubernetes",
      "kubernetesConfigFile" : "anotherFilePointer",
    },
  },

  # The defaults specified here override the baseline defaults which should be
  # specified either in a separate JSON file or in the run harness (or in a database table).
  #
  # remove this from this hiearchy for now 
  "defaults" : {
    # There are just a few parameters that we want to be able to override in every service, rather
    # than having to specify them for each service separately.  These parameters must be fields in 
    # every service class, and must have globally unique names.
    "computeResourceName" : "aHostName"
  
    # Other defaults are specified per service-type.
    # Have one of these sections for each service type (e.g. auctionAppServer, auctionWebServer, etc.)
    "auctionAppServer" : {
      # override the default in every auctionAppServer that doesn't explicitly define jvmOpts
      "jvmOpts" : "-Xmx6G -Xms6G",
  
      # Other fields whose defaults can be overridden
      "cpuRequest" : "1500m",
      "cpuLimit" : "2",
      "memRequest" : "2Gi",
      "memLimit" : "7Gi"
    },
  },

  "workloads" : [
    {
      # Parameters which control the workload to be executed.  This controls the
      # type of both the drivers and the appInstances.
      "type" : "auction",

      "driver" : {
        "numInstances" : 4,

        # Specify a list of compute resources on which to run the drivers. 
        # If there are fewer computeResources specified than driver instances, then
        # will wrap when starting drivers.  If there are more computeResources than 
        # driver instances, then the extras won't be used.
        # If the first computeResource is a kubernetes cluster, then all instances will
        # run on that cluster, and other will be ignored (we should emit a warning). So
        # specifying multiple is only for running drivers on Docker hosts.
        "computeResourceNames" : ["driverClusterName",];
  
        "port" : 7500,
        "portStep" : 1,

        "workloadProfile" : "auction",

        # The tunings are the same for all driver instances
        "jvmOpts" : "-Xmx2g -Xms2g",
        "maxConnPerUser" : 4,
        "threads" : 0, # default to numCpus
        "httpThreads" : 0, # default to 4*numCpus
        "cpuRequest" : "1500m",
        "cpuLimit" : "2",
        "memRequest" : "2Gi",
        "memLimit" : "7Gi"
      },
      "appInstances" : [
        {
          # Only if the runStrategy is custom is it possible to specify a loadPath in an
          # appInstance.  For any other runStratgy, specifying this should be an error.
          # This loadPath should override the global loadPath specified in the runStrategy
          "loadPath" : [
            {"duration" : 300, "users" : 2000, },
            {"duration" : 420, "startUsers" : 2000, "endUsers" : 40000, "timeStep" : 10},
            {"duration" : 120, "endUsers" : 30000, },
            {"duration" : 180, "users" : 30000, },
          ],
          "repeatLoadPath" : true,        

          # Specify the compute resource for this appInstance.  If running on kubernetes or
          # on a single Docker host, then this computeResource is used for all services.
          # If a user wants to assign services instances to specific Docker hosts, then 
          # they must specify the computeResources list in each service type below.
          # If this computeResource is a Kubernetes host, then specifying computeResources
          # in the services is an error.
          "computeResourceName" : "aClusterName",
  
          # Since we are getting rid of the file server, the only remaining options for
          # the image store are mongoDb and memory
          "imageStoreType" : "mongodb",
  
          # Dropping: configurationManager, elasticityService, lbServer, fileServer
          # Prefixing all with auction to distinguish from services for other apps 
          "services" : [
            {
              # This is the type of this service.  It corresponds to a sub-class of Service
              "type" : "auctionDataManager",
  
              # This is the number of instances of this service
              "numInstances" : 1,
              
              # Should only be one computeResource for auctionDataManager
              "computeResourceNames" : [ "aHostName1", ],
    
              "threads" : 6,
              "jvmOpts" : "-Xmx4g -Xms4G",
            },
            {
              # This is the type of this service.  It corresponds to a sub-class of Service
              "type" : "auctionWebServer",
  
              # This is the number of instances of this service
              "numInstances" : 2,
    
              # Specify a list of computeResources on which to run the instances of this
              # service.  This is only for assigning service instances to different Docker hosts.
              # Specifying a kubernetes cluster in this list should be an error.
              # If there are fewer computeResources specified than service instances, then
              # will wrap when starting services.  If there are more computeResources than 
              # service instances, then the extras won't be used.
              # This mechanism eliminates the default service name (e.g. AuctionApp1) to host
              # mapping through DNS.
              "computeResourceNames" : [ "aHostName1", "aHostName2"],
    
    	        # All instances for a service are configured identically in a given appInstance.  The 
              # ability to tune each service instance individually is eliminated.
    
              # In addition to computeResource, every service has these fields
              "impl" : "nginx", # leave the possibility of different service implementations
    	        "cpuRequest" : "1500m",
              "cpuLimit" : "2",
              "memRequest" : "2Gi",
         	    "memLimit" : "7Gi"
              "dockerCpuSetCpus" : "1-4",
    	        "dockerNet" : "bridge",
    
              "httpPort" : 80,
              "httpsPort" : 443,
              "portOffset" : 9000,
              "portStep" : 1,
    
              # Service-specific fields
              "keepalive" : true,
              "keepaliveTimeout" : 120,
              "nginxWorkerConnections" : 0,
    
              # These are only relevant when running on a docker host
              "useNamedVolumes" : false,
              "cacheVolumeName" : "nginxCache",
              "cacheVolumeSize" : "10Gi",
            },
            {
              "type" : "auctionAppServer",
              "numInstances" : 1,
  
              "threads" : 49,
              "jdbcConnections" : 50,
              "jvmOpts" : "-Xms2g -Xmx2g",
    
              "httpPort" : 80,
              "httpsPort" : 443,
              "portOffset" : 8000,
              "portStep" : 1,
    
              # These are tuning knobs for the internals of the auctionApp.  I want to leave them in
              # but will not expost them to users.
              "randomizeImages" : true,
              "useImageWriterThreads" : true,
              "numImageWriterThreads" : 1,
              "numClientUpdateThreads" : 2,
              "numAuctioneerThreads" : 2,
              "highBidQueueConcurrency" : 1,
              "newBidQueueConcurrency" : 1,
              "prewarmAppServers" : true,
              "thumbnailImageCacheSizeMultiplier" : 25,
              "previewImageCacheSizeMultiplier" : 25,
              "fullImageCacheSizeMultiplier" : 25,
            },
            {
              "type" : "auctionBidServer",
              "numInstances" : 1,
            
              "threads" 25,
              "jdbcConnections" : 26,
              "jvmOpts" : "-Xmx4g -Xms4g -XX:+UseG1GC",
    
              "httpPort" : 80,
              "httpsPort" : 443,
              "portOffset" : 10000,
              "portStep" : 1,
            },
            {
              "type" : "auctionCoordinationServer",
              "numInstances" : 3,
   
              "zkClientPort" : 2181,
              "zkPeerPort" : 2888,
              "zkElectionPort" : 3888,
              "portStep" : 1,
            },
            {
              "type" : "auctionMsgServer",
              "numInstances" : 1,
  
              "rabbitmqPort" : 5672,
              "portStep" : 1,
            },
            {
              "type" : "auctionNosqlServer",
              "numInstances" : 1,
  
              "replicated" : false,
              "sharded" : false,
              "replicasPerShard" : 3,
    
              "portStep" : 100,
    
              # Used for Docker
              "useNamedVolumes" : false,
              "dataVolumeName" : "mongodbData",
              "dataVolumeSize" : "200Gi",
              "c1DataVolumeName" : "mongodbC1Data",
              "c1DataVolumeSize" : "10Gi",
              "c2DataVolumeName" : "mongodbC2Data",
              "c2DataVolumeSize" : "10Gi",
              "c3DataVolumeName" : "mongodbC3Data",
              "c3DataVolumeSize" : "10Gi",
    
              # used for Kubernetes
              "dataStorageClass" : "fast",
    
              "mongodbTouch" : true,
              "mongodbTouchFull" : false,
              "mongodbTouchPreview" : false,
            },
            {
              "type" : "auctionDbServer"
              "numInstances" : 1,
              "postgresqlPort" : 5432,
              "portStep" : 1,
    
              "postgresqlSharedBuffers" : 0, 
              "postgresqlSharedBuffersPct" : 0.25,
              "postgresqlEffectiveCacheSize" : 0,
              "postgresqlEffectiveCacheSizePct" : 0.65,
              "postgresqlMaxConnections" : 0,
    
              # Used for Docker
              "useNamedVolumes" : false,
              "dataVolumeName" : "postgresqlData",
              "dataVolumeSize" : "20Gi",
              "logVolumeName" : "postgresqlLogs",
              "logVolumeSize" : "20Gi",
    
              # used for Kubernetes
              "dataStorageClass" : "fast",
              "logStorageClass" : "fast",            
            },
          ],
        }
      ],
    }
  ],
  
  "virtualInfrastructure" : {
    "type" : " vsphere",  
    # The management host for the virtual infrastructure
    "mgmtHost" : {
      "type" : "vcenter",
      "hostname" : "aVcHostname",
      "username" : "ausername",
      "password" : "apassword",
    },
    # A list of viHosts which are the underlying resource in the virtual infrastructure 
    "hosts" : [
      {
        "type" : "esxi",
        "hostname" : "anEsxiHostname",
      },
      {
        "type" : "esxi",
        "hostname" : "anotherEsxiHostname",
      },
    ],
  },

}
